// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: notes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getNoteByUUIDAndWorkspace = `-- name: GetNoteByUUIDAndWorkspace :one
SELECT id, uuid, content, favorite, deleted, trashed, has_content, has_images, has_videos,
       has_open_tasks, has_closed_tasks, has_code, has_audios, has_links, has_files,
       has_quotes, has_tables, workspace_id, created, updated, created_by_id, updated_by_id
FROM note
WHERE uuid = $1
  AND workspace_id = $2
`

type GetNoteByUUIDAndWorkspaceParams struct {
	UUID        string
	WorkspaceID int64
}

func (q *Queries) GetNoteByUUIDAndWorkspace(ctx context.Context, arg GetNoteByUUIDAndWorkspaceParams) (Note, error) {
	row := q.db.QueryRow(ctx, getNoteByUUIDAndWorkspace, arg.UUID, arg.WorkspaceID)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.Content,
		&i.Favorite,
		&i.Deleted,
		&i.Trashed,
		&i.HasContent,
		&i.HasImages,
		&i.HasVideos,
		&i.HasOpenTasks,
		&i.HasClosedTasks,
		&i.HasCode,
		&i.HasAudios,
		&i.HasLinks,
		&i.HasFiles,
		&i.HasQuotes,
		&i.HasTables,
		&i.WorkspaceID,
		&i.Created,
		&i.Updated,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const getNotesWithSortingAndPagination = `-- name: GetNotesWithSortingAndPagination :many
SELECT id, uuid, content, favorite, deleted, trashed, has_content, has_images, has_videos,
       has_open_tasks, has_closed_tasks, has_code, has_audios, has_links, has_files,
       has_quotes, has_tables, workspace_id, created, updated, created_by_id, updated_by_id
FROM note
WHERE workspace_id = $1
  AND deleted = FALSE
  AND trashed = FALSE
  AND has_content = TRUE
  AND (
    (created > $3 AND $4 = 'created_asc')
    OR (created < $3 AND $4 = 'created_dsc')
    OR (updated > $3 AND $4 = 'updated_asc')
    OR (updated < $3 AND $4 = 'updated_dsc')
    OR (created = $3 AND id > $5) -- Tie-breaker for stability
  )
ORDER BY
  CASE
    WHEN $4 = 'created_asc' THEN created
    WHEN $4 = 'created_dsc' THEN created
    WHEN $4 = 'updated_asc' THEN updated
    WHEN $4 = 'updated_dsc' THEN updated
  END ASC,
  id ASC
LIMIT $2
`

type GetNotesWithSortingAndPaginationParams struct {
	WorkspaceID   int64
	Limit         int64
	LastSortValue int64
	SortKey       pgtype.Text
	LastNoteID    int64
}

func (q *Queries) GetNotesWithSortingAndPagination(ctx context.Context, arg GetNotesWithSortingAndPaginationParams) ([]Note, error) {
	rows, err := q.db.Query(ctx, getNotesWithSortingAndPagination,
		arg.WorkspaceID,
		arg.Limit,
		arg.LastSortValue,
		arg.SortKey,
		arg.LastNoteID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.UUID,
			&i.Content,
			&i.Favorite,
			&i.Deleted,
			&i.Trashed,
			&i.HasContent,
			&i.HasImages,
			&i.HasVideos,
			&i.HasOpenTasks,
			&i.HasClosedTasks,
			&i.HasCode,
			&i.HasAudios,
			&i.HasLinks,
			&i.HasFiles,
			&i.HasQuotes,
			&i.HasTables,
			&i.WorkspaceID,
			&i.Created,
			&i.Updated,
			&i.CreatedByID,
			&i.UpdatedByID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trashNoteByUUID = `-- name: TrashNoteByUUID :one
UPDATE note
SET
    trashed = TRUE,
    updated = $1,
    updated_by_id = $2
WHERE uuid = $3
  AND workspace_id = $4
RETURNING id
`

type TrashNoteByUUIDParams struct {
	Updated     int64
	UpdatedByID int64
	UUID        string
	WorkspaceID int64
}

func (q *Queries) TrashNoteByUUID(ctx context.Context, arg TrashNoteByUUIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, trashNoteByUUID,
		arg.Updated,
		arg.UpdatedByID,
		arg.UUID,
		arg.WorkspaceID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const trashNotesByUUIDs = `-- name: TrashNotesByUUIDs :exec
UPDATE note
SET
    trashed = TRUE,
    updated = $1,
    updated_by_id = $2
WHERE uuid = ANY($3)
  AND workspace_id = $4
`

type TrashNotesByUUIDsParams struct {
	Updated     int64
	UpdatedByID int64
	Uuids       []string
	WorkspaceID int64
}

func (q *Queries) TrashNotesByUUIDs(ctx context.Context, arg TrashNotesByUUIDsParams) error {
	_, err := q.db.Exec(ctx, trashNotesByUUIDs,
		arg.Updated,
		arg.UpdatedByID,
		arg.Uuids,
		arg.WorkspaceID,
	)
	return err
}

const upsertNote = `-- name: UpsertNote :one
INSERT INTO note (
    id, uuid, content, favorite, deleted, trashed, has_content, has_images, has_videos,
    has_open_tasks, has_closed_tasks, has_code, has_audios, has_links, has_files,
    has_quotes, has_tables, workspace_id, created, updated, created_by_id, updated_by_id
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9,
    $10, $11, $12, $13, $14, $15,
    $16, $17, $18, $19, $20, $21, $22
)
ON CONFLICT (id) DO UPDATE
SET
    uuid = EXCLUDED.uuid,
    content = EXCLUDED.content,
    favorite = EXCLUDED.favorite,
    deleted = EXCLUDED.deleted,
    trashed = EXCLUDED.trashed,
    has_content = EXCLUDED.has_content,
    has_images = EXCLUDED.has_images,
    has_videos = EXCLUDED.has_videos,
    has_open_tasks = EXCLUDED.has_open_tasks,
    has_closed_tasks = EXCLUDED.has_closed_tasks,
    has_code = EXCLUDED.has_code,
    has_audios = EXCLUDED.has_audios,
    has_links = EXCLUDED.has_links,
    has_files = EXCLUDED.has_files,
    has_quotes = EXCLUDED.has_quotes,
    has_tables = EXCLUDED.has_tables,
    workspace_id = EXCLUDED.workspace_id,
    created = EXCLUDED.created,
    updated = EXCLUDED.updated,
    created_by_id = EXCLUDED.created_by_id,
    updated_by_id = EXCLUDED.updated_by_id
RETURNING id
`

type UpsertNoteParams struct {
	ID             int64
	UUID           string
	Content        string
	Favorite       bool
	Deleted        bool
	Trashed        bool
	HasContent     bool
	HasImages      bool
	HasVideos      bool
	HasOpenTasks   bool
	HasClosedTasks bool
	HasCode        bool
	HasAudios      bool
	HasLinks       bool
	HasFiles       bool
	HasQuotes      bool
	HasTables      bool
	WorkspaceID    int64
	Created        int64
	Updated        int64
	CreatedByID    int64
	UpdatedByID    int64
}

func (q *Queries) UpsertNote(ctx context.Context, arg UpsertNoteParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertNote,
		arg.ID,
		arg.UUID,
		arg.Content,
		arg.Favorite,
		arg.Deleted,
		arg.Trashed,
		arg.HasContent,
		arg.HasImages,
		arg.HasVideos,
		arg.HasOpenTasks,
		arg.HasClosedTasks,
		arg.HasCode,
		arg.HasAudios,
		arg.HasLinks,
		arg.HasFiles,
		arg.HasQuotes,
		arg.HasTables,
		arg.WorkspaceID,
		arg.Created,
		arg.Updated,
		arg.CreatedByID,
		arg.UpdatedByID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
